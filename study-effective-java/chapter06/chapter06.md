# 6장. 열거 타입과 애너테이션
## 다루는 것
- 자바의 특수한 목적의 참조 타입
- 열거 타입(enum) - 클래스의 일종
- 애너테이션(annotation) - 인터페이스의 일종

## 아이템 목록
34. int 상수 대신 열거 타입을 사용하라
35. ordinal 메서드 대신 인스턴스 필드를 사용하라
36. 비트 필드 대신 EnumSet을 사용하라
37. ordinal 인덱싱 대신 EnumMap을 사용하라
38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
39. 명명 패턴보다 애너테이션을 사용하라
40. @Override 애너테이션을 일관되게 사용하라
41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

## 아이템 34. int 상수 대신 열거 타입을 사용하라
> * 열거 타입은 정수 상수보다 더 읽기 쉽고 안전하고 강력하다.
> * 열거 타입은 각 상수를 특정 데이터와 연결지을 수 있다.
> * 하나의 메서드가 상수별로 다르게 동작해야 한다면 상수별 메서드 구현을 사용하자.
> * 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하자.

## 아이템 35. ordinal 메서드 대신 인스턴스 필드를 사용하라
> * 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지 말고, 인스턴스 필드에 저장하자.

## 아이템 36. 비트 필드 대신 EnumSet을 사용하라
> * 열거할 수 있는 타입을 한데 모아 집합 형태로 사용할 때 EnumSet을 사용하자.
> * EnumSet 클래스는 비트 필드 수중은 명료함과 성능을 제공하고 열거 타입의 장점까지 선사한다.
> * 하지만 (Java 9까지는 아직) 불변 EnumSet을 제공하지 않고 임시방편으로 Collections.unmodifiableSet을 EnumSet을 감싸 사용할 수 있다. 

## 아이템 37. ordinal 인덱싱 대신 EnumMap을 사용하라
> * 배열에 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.

## 아이템 38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
> * 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다.

## 아이템 39. 명명 패턴보다 애너테이션을 사용하라
* 명명 패턴의 단점
    - 오타가 나면 안 된다.
    - 올바른 프로그램 요소(클래스, 메서드, ...)에서만 사용되리라 보증할 방법이 없다.
    - 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다.

## 아이템 40. @Override 애너테이션을 일관되게 사용하라
> * 재정의한 모든 메서드에 @Override 애너테이션을 의식적으로 달면 실수를 컴파일러가 바로 알려줄 것이다.
> * 단 하나의 예외, 구체 클래스에서 상위 클래스의 추상 메서드를 재정의한 경우엔 이 애너테이션을 달지 않아도 된다(단다고 해서 해로울 것도 없다).

## 아이템 41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라
- 마커 인터페이스 
    - 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스, e.g. Serializable
- 마커 애너테이션
    - 아무 매개변수 없이 단순히 대상에 마킹한다는 의미를 가진 애너테이션, e.g. @Test
- 메타애너테이션
    - 애너테이션 선언에 다는 애너테이션, e.g. @Retention, @Target


- 마커 인터페이스의 상대적 장점
  - 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있다. 
  - 적용 대상을 더 정밀하게 지정할 수 있다.
- 마커 애너테이션의 상대적 장점
  - 거대한 애너테이션 시스템의 지원을 받는다.
    
> * 마커 인터페이스 - 새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 선택
> * 마커 애너테이션 - 클래스나 인터페이스 외의 프로그램 요소에 마킹해야 하거나, 애너테이션을 적응 활용하는 프레임워크의 일부로 그 마커를 편입시키고자 한다면 선택 